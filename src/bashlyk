#!/bin/bash
#
# $Id$
#
#****h* bashlyk/bashlyk
#  DESCRIPTION
#    bashlyk - сценарий подключения BASHLYK библиотек
#  AUTHOR
#    Damir Sh. Yakupov <yds@bk.ru>
#******
#****d* bashlyk/Required Once
#  DESCRIPTION
#    Глобальная переменная $_BASHLYK обеспечивает
#    защиту от повторного использования данного сценария
#  SOURCE
[ -n "$_BASHLYK" ] && return 0 || _BASHLYK=1
#******
#****v* bashlyk/Init section
#  DESCRIPTION
#    Блок инициализации глобальных переменных
#  SOURCE
[ -s /etc/bashlyk/bashlyk.conf ] && . /etc/bashlyk/bashlyk.conf
: ${_bashlyk_aLib:="std,pid,cnf,ini,opt,log"}
: ${_bashlyk_pathLib:="/usr/share/bashlyk"}
: ${_bashlyk_sArg:=$*}
: ${_bashlyk_bInteract:=1}
: ${_bashlyk_bTerminal:=1}
: ${_bashlyk_sCond4Log:=noterm}
: ${_bashlyk_bNotUseLog:=0}
_bashlyk_pathLib=.

#******
#****f* bashlyk/udfInit
#  SYNOPSIS
#    udfInit
#  DESCRIPTION
#    Подготовка к запуску сценария, определение условий его работы (каталоги 
#    расположения создаваемых файлов, наличие терминала, перенаправления и т.п.)
#    Если запуск выполняется от "root", то каталоги располагаются глобально,
#    согласно стандарта FHS, иначе - в каталогах согласно XDG Base Directory
#    Specification.
#    В случае, если не удалось определить владельца процесса или отсутствует
#    домашний каталог, то иерархия объектов сценария создаются в глобальном
#    временном каталоге, обычно /tmp
#  SOURCE
udfInit() {
 local pathCnf pathRoot pathRun pathLog pathDat sHome
 #
 _bashlyk_sId=${_bashlyk:-bashlyk}
 [ -n "$_bashlyk" ] && _bashlyk_pathPrefix="${_bashlyk}" \
  || _bashlyk_pathPrefix=bashlyk

 _bashlyk_sUser=$(ps -p $$ -o user=)
 _bashlyk_sGroup=$(ps -p $$ -o group=)

 case $_bashlyk_sUser in
  'root')
   _bashlyk_pathCnf="/etc/${_bashlyk_pathPrefix}"
   _bashlyk_pathRun="/var/run/${_bashlyk_pathPrefix}"
   _bashlyk_pathLog="/var/log/${_bashlyk_pathPrefix}"
   _bashlyk_pathDat="/var/lib/${_bashlyk_pathPrefix}"
   [ -s /etc/${_bashlyk_pathPrefix}/bashlyk.conf ] \
    && . /etc/${_bashlyk_pathPrefix}/bashlyk.conf
   ;;
  *)
   if [ -z "$HOME" -o ! -O "$HOME" ]; then
    sHome=$(getent passwd $_bashlyk_sUser | cut -d ":" -f 6)
    [ -n "$sHome" -a -d "$sHome" -a -O "$sHome" ] || \
     sHome="/tmp/${$}_${_bashlyk_sUser}"
   else
    sHome=$HOME
   fi
   _bashlyk_pathRun="${sHome}/.cache/${_bashlyk_pathPrefix}/run"
   _bashlyk_pathLog="${sHome}/.local/share/${_bashlyk_pathPrefix}/log"
   _bashlyk_pathDat="${sHome}/.local/share/${_bashlyk_pathPrefix}/lib"
   _bashlyk_pathCnf="${sHome}/.config/${_bashlyk_pathPrefix}"
   [ -s ${sHome}/.config/bashlyk/bashlyk.conf ] && \
    . ${sHome}/.config/bashlyk/bashlyk.conf
   [ -s ${sHome}/.config/${_bashlyk_pathPrefix}/bashlyk.conf ] && \
    . ${sHome}/.config/${_bashlyk_pathPrefix}/bashlyk.conf
  ;;
 esac

 [ -t 1 ] && _bashlyk_bInteract=1 || _bashlyk_bInteract=0
 tty > /dev/null 2>&1 && _bashlyk_bTerminal=1 || _bashlyk_bTerminal=0
 #
 if [ -n "$(echo "$_bashlyk_sArg" | grep -w 'bashlyk-test')" ]; then
  _bashlyk_aUnit="$(echo "${_bashlyk_sArg#*--bashlyk-test=}" | cut -f1 -d' ' | tr ',' ' ' | grep -v '\-\-bashlyk-test')"
  [ -n "$_bashlyk_aUnit" ] || _bashlyk_aUnit="$(echo ${_bashlyk_aLib} | tr ',' ' ')"
  _bashlyk_sMode='test'
 else
  _bashlyk_sMode='lib'
 fi
 [ -n "$_bashlyk_aUnit" ] || _bashlyk_aUnit="$(echo ${_bashlyk_aLib} | tr ',' ' ')"
}
#******
#****f* bashlyk/udfMain
#  SYNOPSIS
#    udfMain <args>
#  DESCRIPTION
#    Инициализация, подключение модулей, запуск процесса протоколирования
#    в случае наличия перенаправления стандартных устройств или потери терминала
#    в зависимости от значения $_bashlyk_sCond4Log ("noterm" по умолчанию).
#  SOURCE
udfMain() {
 local cmd fn s
 #
 udfInit
 #
# [ "$_bashlyk_sMode" = "test" ] && cmd=${_bashlyk_pathLib}/testunit.sh || cmd=.
 if [ "$_bashlyk_sMode" = "test" ]; then
  cmd=${_bashlyk_pathLib}/testunit.sh
  [ -x $cmd ] || eval 'echo "Error: $cmd not found..."; exit 255'
  for s in $_bashlyk_aUnit; do
   $cmd $s
  done
  [ "$_bashlyk_sMode" = "test" ] && exit 0
 else 
  for s in $_bashlyk_aUnit; do
   fn=${_bashlyk_pathLib}/lib${s}.sh
   [ -s $fn ] && . $fn || eval 'echo "Error: $fn not found..."; exit 255'
  done
 fi

 unset _bashlyk_aUnit _bashlyk_sMode

 case ${_bashlyk_sCond4Log} in
  redirect)
           _bashlyk_bNotUseLog=$_bashlyk_bInteract ;;
    noterm)
           _bashlyk_bNotUseLog=$_bashlyk_bTerminal ;;
         *)
           _bashlyk_bNotUseLog=$_bashlyk_bInteract ;;
 esac
 [ $_bashlyk_bNotUseLog -ne 0 ] || udfSetLog
 return 0
}
#******
#****** bashlyk/Main section
#  DESCRIPTION
#    Вызов udfMain - подключение системы BASHLYK к сценарию
#  SOURCE
udfMain $*
#******
